#!/usr/bin/env node

import { promises as fs } from "node:fs";
import path from "node:path";
import process from "node:process";
import url from "node:url";

const __filename = url.fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const repoRoot = path.resolve(__dirname, "..");
const agentRoot = path.join(repoRoot, "src", "naylence", "agent");
const manifestPath = path.join(agentRoot, "factory-manifest.ts");
const manifestBrowserPath = path.join(agentRoot, "factory-manifest.browser.ts");
const manifestDir = path.dirname(manifestPath);

const IGNORED_DIRECTORIES = new Set(["__tests__", "__mocks__", "node_modules", "dist", "util"]);
const FACTORY_SUFFIX = "-factory.ts";

// Node-only factories that should not be bundled in browser builds.
// These use @vite-ignore to prevent bundlers from following the import.
const NODE_ONLY_MODULES = new Set([
  "./gateway/agent-http-gateway-listener-factory.js",
]);

async function collectFactories(currentDir) {
  const entries = await fs.readdir(currentDir, { withFileTypes: true });
  const discovered = [];

  for (const entry of entries) {
    if (IGNORED_DIRECTORIES.has(entry.name)) {
      continue;
    }

    const entryPath = path.join(currentDir, entry.name);
    if (entry.isDirectory()) {
      const nested = await collectFactories(entryPath);
      discovered.push(...nested);
      continue;
    }

    if (!entry.isFile()) {
      continue;
    }

    if (!entry.name.endsWith(FACTORY_SUFFIX)) {
      continue;
    }

    if (entry.name.endsWith(".d.ts") || entry.name.includes(".test.") || entry.name.includes(".spec.")) {
      continue;
    }

    discovered.push(entryPath);
  }

  return discovered;
}

async function getFactoryModules(filePaths) {
  const filtered = [];

  await Promise.all(
    filePaths.map(async (filePath) => {
      const contents = await fs.readFile(filePath, "utf8");

      if (!contents.includes("FACTORY_META")) {
        return;
      }

      if (!/export\s+default\s+/u.test(contents)) {
        return;
      }

      filtered.push(filePath);
    })
  );

  filtered.sort((a, b) => a.localeCompare(b));
  return filtered;
}

function toImportPath(targetPath) {
  const relative = path.relative(manifestDir, targetPath).replace(/\\/g, "/");
  const base = relative.startsWith(".") ? relative : `./${relative}`;
  return base.replace(/\.ts$/, ".js");
}

function buildManifest(modules) {
  const header = [
    "/**",
    " * AUTO-GENERATED FILE. DO NOT EDIT DIRECTLY.",
    " * Generated by scripts/generate-factory-manifest.mjs",
    " *",
    " * Provides the list of agent-sdk factory modules for registration.",
    " */",
    "",
  ].join("\n");

  const list = JSON.stringify(modules, null, 2);

  const loaderEntries = modules
    .map((specifier) => {
      const importCall = NODE_ONLY_MODULES.has(specifier)
        ? `import(/* webpackIgnore: true */ /* @vite-ignore */ ${JSON.stringify(specifier)})`
        : `import(${JSON.stringify(specifier)})`;
      return `  ${JSON.stringify(specifier)}: () => ${importCall},`;
    })
    .join("\n");

  // Generate the NODE_ONLY_FACTORY_MODULES set
  // Note: We always include the full list of known node-only modules in the Set,
  // even if they are not in the MODULES list (e.g. browser build), to satisfy type checking
  // if the type definition expects them, or just to be safe.
  // However, if they are not in MODULES, they won't be iterated over.
  // But wait, FactoryModuleSpec is derived from MODULES.
  // If MODULES excludes them, then FactoryModuleSpec won't include them.
  // So we should only include those that are present in 'modules'.
  const nodeOnlyList = modules.filter(m => NODE_ONLY_MODULES.has(m));
  const nodeOnlySetEntries = nodeOnlyList.map(m => `  ${JSON.stringify(m)},`).join("\n");

  const body = `
export const MODULES = ${list} as const;

export type FactoryModuleSpec = (typeof MODULES)[number];
export type FactoryModuleLoader = () => Promise<Record<string, unknown>>;

export const MODULE_LOADERS: Record<FactoryModuleSpec, FactoryModuleLoader> = {
${loaderEntries}
};

// Node-only factory modules - skipped at runtime in browser environments
export const NODE_ONLY_FACTORY_MODULES = new Set<FactoryModuleSpec>([
${nodeOnlySetEntries}
]);
`;

  return `${header}${body}`;
}

async function main() {
  const factoryFiles = await collectFactories(agentRoot);

  const uniqueFiles = Array.from(new Set(factoryFiles));
  const factoryModules = await getFactoryModules(uniqueFiles);

  const importSpecifiers = factoryModules.map(toImportPath);
  const browserImportSpecifiers = importSpecifiers.filter(m => !NODE_ONLY_MODULES.has(m));

  const manifestContents = buildManifest(importSpecifiers);
  const browserManifestContents = buildManifest(browserImportSpecifiers);

  await fs.mkdir(manifestDir, { recursive: true });
  await fs.writeFile(manifestPath, manifestContents, "utf8");
  await fs.writeFile(manifestBrowserPath, browserManifestContents, "utf8");

  process.stdout.write(
    `Generated factory manifest with ${importSpecifiers.length} entries at ${path.relative(repoRoot, manifestPath)}\n`
  );
  process.stdout.write(
    `Generated browser factory manifest with ${browserImportSpecifiers.length} entries at ${path.relative(repoRoot, manifestBrowserPath)}\n`
  );
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
